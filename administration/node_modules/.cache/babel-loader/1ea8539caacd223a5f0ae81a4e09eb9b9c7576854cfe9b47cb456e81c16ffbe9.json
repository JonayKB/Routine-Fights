{"ast":null,"code":"import { isBandScale } from \"../../../isBandScale.js\";\nfunction getAsANumber(value) {\n  return value instanceof Date ? value.getTime() : value;\n}\n\n/**\n * For a pointer coordinate, this function returns the dataIndex associated.\n * Returns `-1` if no dataIndex matches.\n */\nexport function getAxisIndex(axisConfig, pointerValue) {\n  const {\n    scale,\n    data: axisData,\n    reverse\n  } = axisConfig;\n  if (!isBandScale(scale)) {\n    const value = scale.invert(pointerValue);\n    if (axisData === undefined) {\n      return -1;\n    }\n    const valueAsNumber = getAsANumber(value);\n    const closestIndex = axisData?.findIndex((pointValue, index) => {\n      const v = getAsANumber(pointValue);\n      if (v > valueAsNumber) {\n        if (index === 0 || Math.abs(valueAsNumber - v) <= Math.abs(valueAsNumber - getAsANumber(axisData[index - 1]))) {\n          return true;\n        }\n      }\n      if (v <= valueAsNumber) {\n        if (index === axisData.length - 1 || Math.abs(getAsANumber(value) - v) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index + 1]))) {\n          return true;\n        }\n      }\n      return false;\n    });\n    return closestIndex;\n  }\n  const dataIndex = scale.bandwidth() === 0 ? Math.floor((pointerValue - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((pointerValue - Math.min(...scale.range())) / scale.step());\n  if (dataIndex < 0 || dataIndex >= axisData.length) {\n    return -1;\n  }\n  return reverse ? axisData.length - 1 - dataIndex : dataIndex;\n}\n\n/**\n * For a pointer coordinate, this function returns the value associated.\n * Returns `null` if the coordinate has no value associated.\n */\nexport function getAxisValue(axisConfig, pointerValue, dataIndex) {\n  const {\n    scale,\n    data: axisData\n  } = axisConfig;\n  if (!isBandScale(scale)) {\n    const value = scale.invert(pointerValue);\n    if (dataIndex < 0) {\n      return value;\n    }\n    return axisData[dataIndex];\n  }\n  if (dataIndex < 0 || dataIndex >= axisData.length) {\n    return null;\n  }\n  return axisData[dataIndex];\n}","map":{"version":3,"names":["isBandScale","getAsANumber","value","Date","getTime","getAxisIndex","axisConfig","pointerValue","scale","data","axisData","reverse","invert","undefined","valueAsNumber","closestIndex","findIndex","pointValue","index","v","Math","abs","length","dataIndex","bandwidth","floor","min","range","step","getAxisValue"],"sources":["/home/jonaykb/Routine-Fights/administration/node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/getAxisValue.js"],"sourcesContent":["import { isBandScale } from \"../../../isBandScale.js\";\nfunction getAsANumber(value) {\n  return value instanceof Date ? value.getTime() : value;\n}\n\n/**\n * For a pointer coordinate, this function returns the dataIndex associated.\n * Returns `-1` if no dataIndex matches.\n */\nexport function getAxisIndex(axisConfig, pointerValue) {\n  const {\n    scale,\n    data: axisData,\n    reverse\n  } = axisConfig;\n  if (!isBandScale(scale)) {\n    const value = scale.invert(pointerValue);\n    if (axisData === undefined) {\n      return -1;\n    }\n    const valueAsNumber = getAsANumber(value);\n    const closestIndex = axisData?.findIndex((pointValue, index) => {\n      const v = getAsANumber(pointValue);\n      if (v > valueAsNumber) {\n        if (index === 0 || Math.abs(valueAsNumber - v) <= Math.abs(valueAsNumber - getAsANumber(axisData[index - 1]))) {\n          return true;\n        }\n      }\n      if (v <= valueAsNumber) {\n        if (index === axisData.length - 1 || Math.abs(getAsANumber(value) - v) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index + 1]))) {\n          return true;\n        }\n      }\n      return false;\n    });\n    return closestIndex;\n  }\n  const dataIndex = scale.bandwidth() === 0 ? Math.floor((pointerValue - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((pointerValue - Math.min(...scale.range())) / scale.step());\n  if (dataIndex < 0 || dataIndex >= axisData.length) {\n    return -1;\n  }\n  return reverse ? axisData.length - 1 - dataIndex : dataIndex;\n}\n\n/**\n * For a pointer coordinate, this function returns the value associated.\n * Returns `null` if the coordinate has no value associated.\n */\nexport function getAxisValue(axisConfig, pointerValue, dataIndex) {\n  const {\n    scale,\n    data: axisData\n  } = axisConfig;\n  if (!isBandScale(scale)) {\n    const value = scale.invert(pointerValue);\n    if (dataIndex < 0) {\n      return value;\n    }\n    return axisData[dataIndex];\n  }\n  if (dataIndex < 0 || dataIndex >= axisData.length) {\n    return null;\n  }\n  return axisData[dataIndex];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}