{"ast":null,"code":"import { getGraphemeCount } from \"./getGraphemeCount.js\";\nimport { degToRad } from \"./degToRad.js\";\nimport { sliceUntil } from \"./sliceUntil.js\";\nconst ELLIPSIS = '…';\nexport function doesTextFitInRect(text, config) {\n  const {\n    width,\n    height,\n    measureText\n  } = config;\n  const angle = degToRad(config.angle);\n  const textSize = measureText(text);\n  const angledWidth = Math.abs(textSize.width * Math.cos(angle)) + Math.abs(textSize.height * Math.sin(angle));\n  const angledHeight = Math.abs(textSize.width * Math.sin(angle)) + Math.abs(textSize.height * Math.cos(angle));\n  return angledWidth <= width && angledHeight <= height;\n}\n\n/** This function finds the best place to clip the text to add an ellipsis.\n *  This function assumes that the {@link doesTextFit} never returns true for longer text after returning false for\n *  shorter text.\n *\n *  @param text Text to ellipsize if needed\n *  @param doesTextFit a function that returns whether a string fits inside a container.\n */\nexport function ellipsize(text, doesTextFit) {\n  if (doesTextFit(text)) {\n    return text;\n  }\n  let shortenedText = text;\n  let step = 1;\n  let by = 1 / 2;\n  const graphemeCount = getGraphemeCount(text);\n  let newLength = graphemeCount;\n  let lastLength = graphemeCount;\n  let longestFittingText = null;\n  do {\n    lastLength = newLength;\n    newLength = Math.floor(graphemeCount * by);\n    if (newLength === 0) {\n      break;\n    }\n    shortenedText = sliceUntil(text, newLength).trim();\n    const fits = doesTextFit(shortenedText + ELLIPSIS);\n    step += 1;\n    if (fits) {\n      longestFittingText = shortenedText;\n      by += 1 / 2 ** step;\n    } else {\n      by -= 1 / 2 ** step;\n    }\n  } while (Math.abs(newLength - lastLength) !== 1);\n  return longestFittingText ? longestFittingText + ELLIPSIS : '';\n}","map":{"version":3,"names":["getGraphemeCount","degToRad","sliceUntil","ELLIPSIS","doesTextFitInRect","text","config","width","height","measureText","angle","textSize","angledWidth","Math","abs","cos","sin","angledHeight","ellipsize","doesTextFit","shortenedText","step","by","graphemeCount","newLength","lastLength","longestFittingText","floor","trim","fits"],"sources":["/home/jonaykb/Routine-Fights/administration/node_modules/@mui/x-charts/esm/internals/ellipsize.js"],"sourcesContent":["import { getGraphemeCount } from \"./getGraphemeCount.js\";\nimport { degToRad } from \"./degToRad.js\";\nimport { sliceUntil } from \"./sliceUntil.js\";\nconst ELLIPSIS = '…';\nexport function doesTextFitInRect(text, config) {\n  const {\n    width,\n    height,\n    measureText\n  } = config;\n  const angle = degToRad(config.angle);\n  const textSize = measureText(text);\n  const angledWidth = Math.abs(textSize.width * Math.cos(angle)) + Math.abs(textSize.height * Math.sin(angle));\n  const angledHeight = Math.abs(textSize.width * Math.sin(angle)) + Math.abs(textSize.height * Math.cos(angle));\n  return angledWidth <= width && angledHeight <= height;\n}\n\n/** This function finds the best place to clip the text to add an ellipsis.\n *  This function assumes that the {@link doesTextFit} never returns true for longer text after returning false for\n *  shorter text.\n *\n *  @param text Text to ellipsize if needed\n *  @param doesTextFit a function that returns whether a string fits inside a container.\n */\nexport function ellipsize(text, doesTextFit) {\n  if (doesTextFit(text)) {\n    return text;\n  }\n  let shortenedText = text;\n  let step = 1;\n  let by = 1 / 2;\n  const graphemeCount = getGraphemeCount(text);\n  let newLength = graphemeCount;\n  let lastLength = graphemeCount;\n  let longestFittingText = null;\n  do {\n    lastLength = newLength;\n    newLength = Math.floor(graphemeCount * by);\n    if (newLength === 0) {\n      break;\n    }\n    shortenedText = sliceUntil(text, newLength).trim();\n    const fits = doesTextFit(shortenedText + ELLIPSIS);\n    step += 1;\n    if (fits) {\n      longestFittingText = shortenedText;\n      by += 1 / 2 ** step;\n    } else {\n      by -= 1 / 2 ** step;\n    }\n  } while (Math.abs(newLength - lastLength) !== 1);\n  return longestFittingText ? longestFittingText + ELLIPSIS : '';\n}"],"mappings":"AAAA,SAASA,gBAAgB,QAAQ,uBAAuB;AACxD,SAASC,QAAQ,QAAQ,eAAe;AACxC,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,MAAMC,QAAQ,GAAG,GAAG;AACpB,OAAO,SAASC,iBAAiBA,CAACC,IAAI,EAAEC,MAAM,EAAE;EAC9C,MAAM;IACJC,KAAK;IACLC,MAAM;IACNC;EACF,CAAC,GAAGH,MAAM;EACV,MAAMI,KAAK,GAAGT,QAAQ,CAACK,MAAM,CAACI,KAAK,CAAC;EACpC,MAAMC,QAAQ,GAAGF,WAAW,CAACJ,IAAI,CAAC;EAClC,MAAMO,WAAW,GAAGC,IAAI,CAACC,GAAG,CAACH,QAAQ,CAACJ,KAAK,GAAGM,IAAI,CAACE,GAAG,CAACL,KAAK,CAAC,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACH,QAAQ,CAACH,MAAM,GAAGK,IAAI,CAACG,GAAG,CAACN,KAAK,CAAC,CAAC;EAC5G,MAAMO,YAAY,GAAGJ,IAAI,CAACC,GAAG,CAACH,QAAQ,CAACJ,KAAK,GAAGM,IAAI,CAACG,GAAG,CAACN,KAAK,CAAC,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACH,QAAQ,CAACH,MAAM,GAAGK,IAAI,CAACE,GAAG,CAACL,KAAK,CAAC,CAAC;EAC7G,OAAOE,WAAW,IAAIL,KAAK,IAAIU,YAAY,IAAIT,MAAM;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASU,SAASA,CAACb,IAAI,EAAEc,WAAW,EAAE;EAC3C,IAAIA,WAAW,CAACd,IAAI,CAAC,EAAE;IACrB,OAAOA,IAAI;EACb;EACA,IAAIe,aAAa,GAAGf,IAAI;EACxB,IAAIgB,IAAI,GAAG,CAAC;EACZ,IAAIC,EAAE,GAAG,CAAC,GAAG,CAAC;EACd,MAAMC,aAAa,GAAGvB,gBAAgB,CAACK,IAAI,CAAC;EAC5C,IAAImB,SAAS,GAAGD,aAAa;EAC7B,IAAIE,UAAU,GAAGF,aAAa;EAC9B,IAAIG,kBAAkB,GAAG,IAAI;EAC7B,GAAG;IACDD,UAAU,GAAGD,SAAS;IACtBA,SAAS,GAAGX,IAAI,CAACc,KAAK,CAACJ,aAAa,GAAGD,EAAE,CAAC;IAC1C,IAAIE,SAAS,KAAK,CAAC,EAAE;MACnB;IACF;IACAJ,aAAa,GAAGlB,UAAU,CAACG,IAAI,EAAEmB,SAAS,CAAC,CAACI,IAAI,CAAC,CAAC;IAClD,MAAMC,IAAI,GAAGV,WAAW,CAACC,aAAa,GAAGjB,QAAQ,CAAC;IAClDkB,IAAI,IAAI,CAAC;IACT,IAAIQ,IAAI,EAAE;MACRH,kBAAkB,GAAGN,aAAa;MAClCE,EAAE,IAAI,CAAC,GAAG,CAAC,IAAID,IAAI;IACrB,CAAC,MAAM;MACLC,EAAE,IAAI,CAAC,GAAG,CAAC,IAAID,IAAI;IACrB;EACF,CAAC,QAAQR,IAAI,CAACC,GAAG,CAACU,SAAS,GAAGC,UAAU,CAAC,KAAK,CAAC;EAC/C,OAAOC,kBAAkB,GAAGA,kBAAkB,GAAGvB,QAAQ,GAAG,EAAE;AAChE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}